diff --git a/README.md b/README.md
index 2621eeba50956345300d2399e33c3d102f8de007..db029af41378daf65b09d030e3a0094f40e14955 100644
--- a/README.md
+++ b/README.md
@@ -4,106 +4,118 @@ A production-oriented starter for a ride sharing / carpool app.
 
 ## Stack
 - Backend: ASP.NET Core (net10.0), EF Core, SQL Server
 - Auth: Google ID token login + JWT access + refresh token rotation
 - Email verification gate: **create trip** and **book trip** require verified email
 - Frontend: Vue 3 + TypeScript + Vite + Tailwind + Pinia + Heroicons
 
 ## Whatâ€™s implemented
 - Google login (`/api/auth/google`) and token refresh (`/api/auth/refresh`)
 - Email verification flow
   - backend creates verification token and sends email
   - dev mode writes emails to: `TripShare.Api/App_Data/dev-emails`
   - verify endpoint: `POST /api/users/verify-email?token=...`
 - Trips
   - create trip with route points and per-segment prices
   - search + trip details
 - Bookings
   - create booking with seat allocation across selected segments
   - driver accept/reject/complete, passenger cancel
   - concurrency protection via serializable transaction + retry
 - Ratings
   - allow rating only after booking is completed, one rating per user per booking
 - Logging
   - Serilog console + rolling file logs under `TripShare.Api/Logs/`
   - correlation id header: `X-Correlation-Id`
+- SMS OTP via Text.lk (phone-based login / verification)
 
 ## Run locally (Visual Studio 2022)
 ### 1) Database
 Install SQL Server (LocalDB or full SQL Server).
 
 Set the connection string in `src/TripShare.Api/appsettings.Development.json`:
 
 `Server=localhost;Database=TripShareDb;Trusted_Connection=True;TrustServerCertificate=True;`
 
 Or use SQL auth as needed.
 
 ### 2) Backend
 Open `TripShare.sln` in VS 2022.
 Set startup project: `TripShare.Api`
 Run. Swagger opens at:
 - `http://localhost:8080/swagger`
 
 ### 3) Frontend (Vue)
 Open folder `src/tripshare-web` in VS (or any terminal).
 
 Copy `.env.example` to `.env` and set:
 - `VITE_API_BASE=http://localhost:8080`
 - `VITE_GOOGLE_CLIENT_ID=...`
 
 Then:
 ```bash
 npm install
 npm run dev
 ```
 Frontend runs on:
 - `http://localhost:5173`
 
 ## Email verification gate
 - After signing in, the API sends a verification email.
 - In dev mode it writes a HTML file under:
   `TripShare.Api/bin/Debug/net8.0/App_Data/dev-emails/` (or the publish folder)
 - Open that file and click the verification link.
 - Once verified, you can create trips and book.
 
+## SMS OTP (Text.lk)
+- Configure `Sms` in `src/TripShare.Api/appsettings*.json` (or environment variables):
+  - `Sms:Provider=TextLk`
+  - `Sms:TextLk:ApiKey`, `Sms:TextLk:SenderId`, optional `Sms:TextLk:Endpoint`
+  - `Sms:OtpMinutes` controls OTP expiry.
+- Endpoints:
+  - `POST /api/auth/sms/request` `{ phoneNumber }`
+  - `POST /api/auth/sms/verify` `{ phoneNumber, otp }`
+- Frontend login modal now supports SMS alongside Google.
+
 ## Ads (non-invasive)
 The UI includes **placeholder ad slots** in:
 - Home sidebar
 - Trip details bottom
 - Profile sidebar
 - Bookings sidebar
 
 Replace `AdSlot.vue` with your ad provider integration (AdSense, etc.). Keep it subtle (no popups).
 
 ## Security notes
 - Refresh tokens are stored as SHA-256 hashes
 - Refresh token rotation is enabled
 - Actions requiring verified email are protected by `RequireVerifiedEmailAttribute`
 - Do not commit secrets. Use environment variables / user secrets for:
   - `Jwt:SigningKey`
   - SMTP credentials (if switching Email Mode to SMTP)
   - Google Client IDs
+  - Text.lk API credentials (`Sms:TextLk:ApiKey`, `Sms:TextLk:SenderId`)
 
 ## Docker (optional)
 `docker-compose.yml` brings up:
 - SQL Server 2022
 - API on 8080
 - Web on 5173
 
 ```bash
 docker compose up --build
 ```
 
 ## Production readiness upgrades (included)
 - Deterministic DB schema setup using **DbUp** embedded SQL scripts (see `src/TripShare.Api/DbUp/Scripts`).
   - Production uses DbUp by default.
   - Development falls back to `EnsureCreated` if scripts are not embedded/available.
 - Configurable **CORS** via `Cors:AllowedOrigins` (no more `AllowAnyOrigin`).
 - Health endpoint: `GET /health`
 - Logging: Serilog (console + rolling file logs) with correlation ids.
 
 ## Running locally (developer friendly)
 ### Backend
 - Open `TripShare.sln` and run `TripShare.Api`.
 - Update `src/TripShare.Api/appsettings.Development.json` connection string.
 - Swagger: `http://localhost:8080/swagger`
 
diff --git a/src/TripShare.Api/Controllers/AuthController.cs b/src/TripShare.Api/Controllers/AuthController.cs
index 189e88669a6764fd87abc7721ff38710977e2dc1..ea0ba66b56d9ccb2e89583179789abf522ca59ac 100644
--- a/src/TripShare.Api/Controllers/AuthController.cs
+++ b/src/TripShare.Api/Controllers/AuthController.cs
@@ -1,25 +1,38 @@
 using Microsoft.AspNetCore.Mvc;
 using Microsoft.AspNetCore.RateLimiting;
 using TripShare.Application.Contracts;
 using TripShare.Api.Services;
 
 namespace TripShare.Api.Controllers;
 
 [ApiController]
 [Route("api/auth")]
 public sealed class AuthController : ControllerBase
 {
     private readonly AuthService _auth;
 
     public AuthController(AuthService auth) => _auth = auth;
 
     [HttpPost("google")]
     [EnableRateLimiting("auth")]
     public async Task<ActionResult<AuthResponse>> Google([FromBody] GoogleLoginRequest req, CancellationToken ct)
         => Ok(await _auth.GoogleLoginAsync(req, ct));
 
     [HttpPost("refresh")]
     [EnableRateLimiting("auth")]
     public async Task<ActionResult<AuthResponse>> Refresh([FromBody] RefreshRequest req, CancellationToken ct)
         => Ok(await _auth.RefreshAsync(req, ct));
+
+    [HttpPost("sms/request")]
+    [EnableRateLimiting("auth")]
+    public async Task<ActionResult> RequestSmsOtp([FromBody] SmsOtpRequest req, CancellationToken ct)
+    {
+        await _auth.RequestSmsOtpAsync(req, ct);
+        return Accepted();
+    }
+
+    [HttpPost("sms/verify")]
+    [EnableRateLimiting("auth")]
+    public async Task<ActionResult<AuthResponse>> VerifySmsOtp([FromBody] SmsOtpVerifyRequest req, CancellationToken ct)
+        => Ok(await _auth.VerifySmsOtpAsync(req, ct));
 }
diff --git a/src/TripShare.Api/DbUp/Scripts/002_sms_otp.sql b/src/TripShare.Api/DbUp/Scripts/002_sms_otp.sql
new file mode 100644
index 0000000000000000000000000000000000000000..9afc5279ba1e3c7da60c6ff2d79860336f9eeba9
--- /dev/null
+++ b/src/TripShare.Api/DbUp/Scripts/002_sms_otp.sql
@@ -0,0 +1,27 @@
+-- Phone verification flag
+IF COL_LENGTH('dbo.Users', 'PhoneVerified') IS NULL
+BEGIN
+    ALTER TABLE dbo.Users ADD PhoneVerified BIT NOT NULL CONSTRAINT DF_Users_PhoneVerified DEFAULT(0);
+END
+IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_Users_PhoneNumber' AND object_id = OBJECT_ID('dbo.Users'))
+    CREATE INDEX IX_Users_PhoneNumber ON dbo.Users(PhoneNumber);
+
+-- SMS OTP tokens
+IF OBJECT_ID('dbo.SmsOtpTokens','U') IS NULL
+BEGIN
+CREATE TABLE dbo.SmsOtpTokens (
+    Id UNIQUEIDENTIFIER NOT NULL CONSTRAINT PK_SmsOtpTokens PRIMARY KEY,
+    UserId UNIQUEIDENTIFIER NOT NULL,
+    PhoneNumber NVARCHAR(64) NOT NULL,
+    TokenHash NVARCHAR(256) NOT NULL,
+    ExpiresAt DATETIMEOFFSET NOT NULL,
+    CreatedAt DATETIMEOFFSET NOT NULL,
+    UsedAt DATETIMEOFFSET NULL,
+    CONSTRAINT FK_SmsOtpTokens_Users FOREIGN KEY(UserId) REFERENCES dbo.Users(Id)
+);
+END
+
+IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_SmsOtpTokens_UserId' AND object_id = OBJECT_ID('dbo.SmsOtpTokens'))
+    CREATE INDEX IX_SmsOtpTokens_UserId ON dbo.SmsOtpTokens(UserId);
+IF NOT EXISTS (SELECT 1 FROM sys.indexes WHERE name = 'IX_SmsOtpTokens_PhoneNumber' AND object_id = OBJECT_ID('dbo.SmsOtpTokens'))
+    CREATE INDEX IX_SmsOtpTokens_PhoneNumber ON dbo.SmsOtpTokens(PhoneNumber);
diff --git a/src/TripShare.Api/Program.cs b/src/TripShare.Api/Program.cs
index 88422946461860509778f64c06e1bfe6ed1b8f6c..ba6d8b2dbba1057e43dd9641f3d2ad90130fc800 100644
--- a/src/TripShare.Api/Program.cs
+++ b/src/TripShare.Api/Program.cs
@@ -37,95 +37,98 @@ builder.Services.AddCors(options =>
         if (builder.Environment.IsDevelopment() || origins.Length == 0)
         {
             // Dev-friendly default: Vue dev server + Swagger UI usage
             policy
                 .AllowAnyHeader()
                 .AllowAnyMethod()
                 .SetIsOriginAllowed(_ => true)
                 .AllowCredentials();
         }
         else
         {
             policy
                 .WithOrigins(origins)
                 .AllowAnyHeader()
                 .AllowAnyMethod()
                 .AllowCredentials();
         }
     });
 });
 
 builder.Services.AddHealthChecks();
 
 builder.Services.AddEndpointsApiExplorer();
 builder.Services.AddSwaggerGen();
 
+builder.Services.AddHttpClient();
+
 // Rate limiting for auth endpoints (simple baseline)
 builder.Services.AddRateLimiter(opt =>
 {
     opt.AddPolicy("auth", context =>
         RateLimitPartition.GetFixedWindowLimiter(
             partitionKey: context.Connection.RemoteIpAddress?.ToString() ?? "unknown",
             factory: _ => new FixedWindowRateLimiterOptions
             {
                 PermitLimit = 20,
                 Window = TimeSpan.FromMinutes(1),
                 QueueProcessingOrder = System.Threading.RateLimiting.QueueProcessingOrder.OldestFirst,
                 QueueLimit = 0
             }));
 });
 
 // EF Core
 builder.Services.AddDbContext<AppDbContext>(opt =>
 {
     opt.UseSqlServer(builder.Configuration.GetConnectionString("Default"));
 });
 
 // Auth
 var jwt = builder.Configuration.GetSection("Jwt");
 var signingKey = jwt["SigningKey"] ?? throw new InvalidOperationException("Jwt:SigningKey missing");
 builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
     .AddJwtBearer(opt =>
     {
         opt.TokenValidationParameters = new TokenValidationParameters
         {
             ValidateIssuer = true,
             ValidateAudience = true,
             ValidateIssuerSigningKey = true,
             ValidIssuer = jwt["Issuer"],
             ValidAudience = jwt["Audience"],
             IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(signingKey)),
             ClockSkew = TimeSpan.FromSeconds(30)
         };
     });
 
 builder.Services.AddAuthorization();
 
 // App services
 builder.Services.AddScoped<ITokenService, TokenService>();
 builder.Services.AddScoped<IGoogleIdTokenValidator, GoogleIdTokenValidator>();
 builder.Services.AddScoped<IEmailSender, EmailSenderFactory>();
+builder.Services.AddScoped<ISmsSender, TextLkSmsSender>();
 builder.Services.AddScoped<AuthService>();
 builder.Services.AddScoped<TripService>();
 builder.Services.AddScoped<BookingService>();
 builder.Services.AddScoped<RatingService>();
 builder.Services.AddScoped<NotificationService>();
 builder.Services.AddScoped<BlockService>();
 builder.Services.AddScoped<ReportService>();
 builder.Services.AddScoped<AdminService>();
 builder.Services.AddHostedService<BookingHousekeepingService>();
 
 var app = builder.Build();
 
 app.UseSerilogRequestLogging();
 app.UseMiddleware<ErrorHandlingMiddleware>();
 app.UseMiddleware<CorrelationIdMiddleware>();
 
 app.UseSwagger();
 app.UseSwaggerUI();
 
 app.UseCors("Default");
 
 app.UseRateLimiter();
 app.UseAuthentication();
 app.UseAuthorization();
 
diff --git a/src/TripShare.Api/Services/AuthService.cs b/src/TripShare.Api/Services/AuthService.cs
index 032dcfb8650153423c8d5007f613bf8b6d803699..8ff970206e1263911c78935cee9b5794c8ddfe7d 100644
--- a/src/TripShare.Api/Services/AuthService.cs
+++ b/src/TripShare.Api/Services/AuthService.cs
@@ -1,56 +1,59 @@
 using Microsoft.EntityFrameworkCore;
 using TripShare.Application.Abstractions;
 using TripShare.Application.Contracts;
 using TripShare.Domain.Entities;
 using TripShare.Infrastructure.Data;
 
 namespace TripShare.Api.Services;
 
 public sealed class AuthService
 {
     private readonly AppDbContext _db;
     private readonly ITokenService _tokens;
     private readonly IGoogleIdTokenValidator _google;
     private readonly IEmailSender _email;
+    private readonly ISmsSender _sms;
     private readonly IConfiguration _cfg;
     private readonly ILogger<AuthService> _log;
     private readonly IHttpContextAccessor _http;
 
     public AuthService(
         AppDbContext db,
         ITokenService tokens,
         IGoogleIdTokenValidator google,
         IEmailSender email,
+        ISmsSender sms,
         IConfiguration cfg,
         ILogger<AuthService> log,
         IHttpContextAccessor http)
     {
         _db = db;
         _tokens = tokens;
         _google = google;
         _email = email;
+        _sms = sms;
         _cfg = cfg;
         _log = log;
         _http = http;
     }
 
     public async Task<AuthResponse> GoogleLoginAsync(GoogleLoginRequest req, CancellationToken ct)
     {
         var clientId = _cfg["Auth:Google:ClientId"] ?? throw new InvalidOperationException("Auth:Google:ClientId missing");
         var payload = await _google.ValidateAsync(req.IdToken, clientId, ct);
 
         var user = await _db.Users.SingleOrDefaultAsync(x => x.AuthProvider == "google" && x.ProviderUserId == payload.Sub, ct);
         if (user is null)
         {
             user = await _db.Users.SingleOrDefaultAsync(x => x.Email == payload.Email, ct);
         }
 
         if (user is null)
         {
             user = new User
             {
                 Email = payload.Email,
                 DisplayName = payload.Name ?? payload.Email.Split('@')[0],
                 PhotoUrl = payload.Picture,
                 AuthProvider = "google",
                 ProviderUserId = payload.Sub,
@@ -127,59 +130,167 @@ public sealed class AuthService
         return new AuthResponse(access, newRefresh, RequiresEmailVerification: !token.User.EmailVerified, IsSuspended: false, Me(token.User));
     }
 
     public async Task ResendVerificationAsync(Guid userId, CancellationToken ct)
     {
         var user = await _db.Users.SingleAsync(x => x.Id == userId, ct);
         if (user.EmailVerified) return;
         await SendVerificationEmailInternalAsync(user, ct);
     }
 
     public async Task VerifyEmailAsync(string token, CancellationToken ct)
     {
         var hash = _tokens.HashToken(token);
         var rec = await _db.EmailVerificationTokens.Include(x => x.User)
             .SingleOrDefaultAsync(x => x.TokenHash == hash, ct);
 
         if (rec?.User is null || !rec.IsValid)
             throw new InvalidOperationException("Verification link is invalid or expired.");
 
         rec.UsedAt = DateTimeOffset.UtcNow;
         rec.User.EmailVerified = true;
 
         await _db.SaveChangesAsync(ct);
     }
 
+    public async Task RequestSmsOtpAsync(SmsOtpRequest req, CancellationToken ct)
+    {
+        var phone = NormalizePhone(req.PhoneNumber);
+        if (string.IsNullOrWhiteSpace(phone))
+            throw new InvalidOperationException("Phone number is required.");
+
+        var expiryMinutes = int.TryParse(_cfg["Sms:OtpMinutes"], out var m) ? m : 10;
+
+        var user = await _db.Users.SingleOrDefaultAsync(x => x.PhoneNumber == phone, ct);
+        if (user is null)
+        {
+            var digits = new string(phone.Where(char.IsDigit).ToArray());
+            var aliasEmail = $"sms{digits}@tripshare-sms.local";
+            var display = $"User {TrimForDisplay(phone)}";
+            user = new User
+            {
+                Email = aliasEmail,
+                DisplayName = display,
+                PhoneNumber = phone,
+                AuthProvider = "sms",
+                ProviderUserId = phone,
+                EmailVerified = false
+            };
+            _db.Users.Add(user);
+        }
+        else if (user.IsSuspended)
+        {
+            throw new InvalidOperationException("Account is suspended.");
+        }
+
+        var active = await _db.SmsOtpTokens
+            .Where(x => x.UserId == user.Id && x.UsedAt == null && x.ExpiresAt > DateTimeOffset.UtcNow)
+            .ToListAsync(ct);
+        foreach (var a in active) a.ExpiresAt = DateTimeOffset.UtcNow.AddMinutes(-1);
+
+        var otp = Random.Shared.Next(100000, 999999).ToString();
+        var hash = _tokens.HashToken(otp);
+        _db.SmsOtpTokens.Add(new SmsOtpToken
+        {
+            UserId = user.Id,
+            PhoneNumber = phone,
+            TokenHash = hash,
+            ExpiresAt = DateTimeOffset.UtcNow.AddMinutes(expiryMinutes)
+        });
+
+        await _db.SaveChangesAsync(ct);
+
+        var msg = $"Your TripShare code is {otp}. It expires in {expiryMinutes} minutes.";
+        await _sms.SendAsync(phone, msg, ct);
+        _log.LogInformation("SMS OTP sent to {Phone}", phone);
+    }
+
+    public async Task<AuthResponse> VerifySmsOtpAsync(SmsOtpVerifyRequest req, CancellationToken ct)
+    {
+        var phone = NormalizePhone(req.PhoneNumber);
+        var otp = req.Otp?.Trim();
+        if (string.IsNullOrWhiteSpace(phone) || string.IsNullOrWhiteSpace(otp))
+            throw new InvalidOperationException("Phone and OTP are required.");
+
+        var hash = _tokens.HashToken(otp);
+        var token = await _db.SmsOtpTokens
+            .Include(x => x.User)
+            .Where(x => x.PhoneNumber == phone && x.TokenHash == hash && x.UsedAt == null)
+            .OrderByDescending(x => x.CreatedAt)
+            .FirstOrDefaultAsync(ct);
+
+        if (token?.User is null || !token.IsValid)
+            throw new InvalidOperationException("Invalid or expired code.");
+
+        token.UsedAt = DateTimeOffset.UtcNow;
+
+        var user = token.User;
+        if (user.IsSuspended)
+            throw new InvalidOperationException("Account is suspended.");
+        user.PhoneNumber ??= phone;
+        user.PhoneVerified = true;
+        user.EmailVerified = true; // treat verified phone as verified gate
+        user.LastLoginAt = DateTimeOffset.UtcNow;
+
+        var access = _tokens.CreateAccessToken(user.Id, user.Email, user.Role, user.EmailVerified);
+        var (refresh, refreshHash) = _tokens.CreateRefreshToken();
+        _db.RefreshTokens.Add(new RefreshToken
+        {
+            UserId = user.Id,
+            TokenHash = refreshHash,
+            ExpiresAt = DateTimeOffset.UtcNow.AddDays(int.TryParse(_cfg["Jwt:RefreshTokenDays"], out var d) ? d : 30),
+            CreatedIp = _http.HttpContext?.Connection.RemoteIpAddress?.ToString(),
+            UserAgent = _http.HttpContext?.Request.Headers.UserAgent.ToString()
+        });
+
+        await _db.SaveChangesAsync(ct);
+
+        return new AuthResponse(access, refresh, RequiresEmailVerification: false, IsSuspended: user.IsSuspended, Me(user));
+    }
+
     private async Task SendVerificationEmailInternalAsync(User user, CancellationToken ct)
     {
         // invalidate previous active tokens (optional)
         var active = await _db.EmailVerificationTokens.Where(x => x.UserId == user.Id && x.UsedAt == null && x.ExpiresAt > DateTimeOffset.UtcNow).ToListAsync(ct);
         foreach (var a in active) a.ExpiresAt = DateTimeOffset.UtcNow.AddMinutes(-1);
 
         var token = Convert.ToBase64String(Guid.NewGuid().ToByteArray()) + Convert.ToBase64String(Guid.NewGuid().ToByteArray());
         var hash = _tokens.HashToken(token);
         var hours = int.TryParse(_cfg["Email:Verification:TokenHours"], out var h) ? h : 24;
 
         _db.EmailVerificationTokens.Add(new EmailVerificationToken
         {
             UserId = user.Id,
             TokenHash = hash,
             ExpiresAt = DateTimeOffset.UtcNow.AddHours(hours)
         });
 
         await _db.SaveChangesAsync(ct);
 
         var webBase = _cfg["Email:Verification:WebBaseUrl"] ?? "http://localhost:5173";
         var link = $"{webBase.TrimEnd('/')}/verify-email?token={Uri.EscapeDataString(token)}";
 
         var body = $@"
 <p>Hi {System.Net.WebUtility.HtmlEncode(user.DisplayName)},</p>
 <p>Please verify your email to create or book trips.</p>
 <p><a href=""{link}"">Verify Email</a></p>
 <p>If you did not request this, you can ignore this email.</p>";
 
         await _email.SendAsync(user.Email, "Verify your TripShare email", body, ct);
         _log.LogInformation("Verification email queued for {Email}", user.Email);
     }
 
     private static UserMeDto Me(User u) => new(u.Id, u.Email, u.EmailVerified, u.DisplayName, u.PhotoUrl, u.IsDriver, u.Role);
+
+    private static string NormalizePhone(string phone)
+    {
+        var trimmed = phone.Trim();
+        if (trimmed.StartsWith("00")) trimmed = "+" + trimmed[2..];
+        return trimmed.Replace(" ", "").Replace("-", "");
+    }
+
+    private static string TrimForDisplay(string phone)
+    {
+        var digits = new string(phone.Where(char.IsDigit).ToArray());
+        return digits.Length >= 4 ? digits[^4..] : digits;
+    }
 }
diff --git a/src/TripShare.Api/Services/TextLkSmsSender.cs b/src/TripShare.Api/Services/TextLkSmsSender.cs
new file mode 100644
index 0000000000000000000000000000000000000000..d3b97cee794fa367f60cac32fc817c777d7c0f73
--- /dev/null
+++ b/src/TripShare.Api/Services/TextLkSmsSender.cs
@@ -0,0 +1,56 @@
+using System.Net.Http.Headers;
+using System.Text;
+using System.Text.Json;
+using TripShare.Application.Abstractions;
+
+namespace TripShare.Api.Services;
+
+public sealed class TextLkSmsSender : ISmsSender
+{
+    private readonly IHttpClientFactory _httpClientFactory;
+    private readonly IConfiguration _cfg;
+    private readonly ILogger<TextLkSmsSender> _log;
+
+    public TextLkSmsSender(IHttpClientFactory httpClientFactory, IConfiguration cfg, ILogger<TextLkSmsSender> log)
+    {
+        _httpClientFactory = httpClientFactory;
+        _cfg = cfg;
+        _log = log;
+    }
+
+    public async Task SendAsync(string phoneNumber, string message, CancellationToken ct)
+    {
+        var provider = _cfg["Sms:Provider"] ?? "TextLk";
+        if (!provider.Equals("TextLk", StringComparison.OrdinalIgnoreCase))
+        {
+            _log.LogWarning("SMS provider set to {Provider} but no implementation exists. Skipping SMS.", provider);
+            return;
+        }
+
+        var apiKey = _cfg["Sms:TextLk:ApiKey"] ?? throw new InvalidOperationException("Sms:TextLk:ApiKey missing");
+        var senderId = _cfg["Sms:TextLk:SenderId"] ?? throw new InvalidOperationException("Sms:TextLk:SenderId missing");
+        var endpoint = _cfg["Sms:TextLk:Endpoint"] ?? "https://app.text.lk/api/v3/sms/send";
+
+        using var client = _httpClientFactory.CreateClient(nameof(TextLkSmsSender));
+        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
+        client.DefaultRequestHeaders.Add("Authorization", $"Bearer {apiKey}");
+
+        var payload = new
+        {
+            sender_id = senderId,
+            recipient = phoneNumber,
+            message
+        };
+
+        var json = JsonSerializer.Serialize(payload);
+        using var content = new StringContent(json, Encoding.UTF8, "application/json");
+        var resp = await client.PostAsync(endpoint, content, ct);
+
+        if (!resp.IsSuccessStatusCode)
+        {
+            var body = await resp.Content.ReadAsStringAsync(ct);
+            _log.LogError("Text.lk SMS send failed. Status: {Status} Body: {Body}", resp.StatusCode, body);
+            throw new InvalidOperationException("Failed to send SMS.");
+        }
+    }
+}
diff --git a/src/TripShare.Api/appsettings.Development.json b/src/TripShare.Api/appsettings.Development.json
index 2842cc46f91ae7db4a4fb8ca1910b393f4ad5ac8..5e17e52797165a6f7364e290b669945e046a1be1 100644
--- a/src/TripShare.Api/appsettings.Development.json
+++ b/src/TripShare.Api/appsettings.Development.json
@@ -1,17 +1,26 @@
 {
   "ConnectionStrings": {
     "Default": "Server=localhost,1433;Database=TripShareDb;User Id=sa;Password=Your_password123;TrustServerCertificate=True;"
   },
   "Email": {
     "Mode": "DevFile",
     "Verification": {
       "WebBaseUrl": "http://localhost:5173"
     },
     "DevFileOutputDir": "App_Data/dev-emails"
   },
+  "Sms": {
+    "Provider": "TextLk",
+    "OtpMinutes": 10,
+    "TextLk": {
+      "ApiKey": "DEV_API_KEY",
+      "SenderId": "TripShare",
+      "Endpoint": "https://app.text.lk/api/v3/sms/send"
+    }
+  },
   "Cors": {
     "AllowedOrigins": [
       "http://localhost:5173"
     ]
   }
-}
\ No newline at end of file
+}
diff --git a/src/TripShare.Api/appsettings.json b/src/TripShare.Api/appsettings.json
index eceee1f40dd2f7c87c72096bfd91374e12abee2e..5165943a65697fc14a45de64d9b21441d8e16cea 100644
--- a/src/TripShare.Api/appsettings.json
+++ b/src/TripShare.Api/appsettings.json
@@ -8,48 +8,57 @@
     "SigningKey": "CHANGE_ME_TO_A_LONG_RANDOM_SECRET_AT_LEAST_64_CHARS________________________________",
     "AccessTokenMinutes": 30,
     "RefreshTokenDays": 30
   },
   "Auth": {
     "Google": {
       "ClientId": "PASTE_YOUR_GOOGLE_WEB_CLIENT_ID.apps.googleusercontent.com"
     }
   },
   "Email": {
     "Mode": "DevFile",
     "FromName": "TripShare",
     "FromEmail": "no-reply@tripshare.lk",
     "Smtp": {
       "Host": "",
       "Port": 587,
       "UseSsl": true,
       "Username": "",
       "Password": ""
     },
     "Verification": {
       "TokenHours": 24,
       "WebBaseUrl": "http://localhost:5173"
     }
   },
+  "Sms": {
+    "Provider": "TextLk",
+    "OtpMinutes": 10,
+    "TextLk": {
+      "ApiKey": "PASTE_YOUR_TEXT_LK_API_KEY",
+      "SenderId": "TripShare",
+      "Endpoint": "https://app.text.lk/api/v3/sms/send"
+    }
+  },
   "RateLimiting": {
     "Enabled": true
   },
   "Serilog": {
     "MinimumLevel": {
       "Default": "Information",
       "Override": {
         "Microsoft": "Warning",
         "Microsoft.Hosting.Lifetime": "Information"
       }
     }
   },
   "AllowedHosts": "*",
   "Cors": {
     "AllowedOrigins": [
       "http://localhost:5173",
       "https://your-domain.com"
     ]
   },
   "ApplicationInsights": {
     "ConnectionString": ""
   }
-}
\ No newline at end of file
+}
diff --git a/src/TripShare.Application/Abstractions/ISmsSender.cs b/src/TripShare.Application/Abstractions/ISmsSender.cs
new file mode 100644
index 0000000000000000000000000000000000000000..387475f77f6aebc97b8d5459a87fc95a6c61d187
--- /dev/null
+++ b/src/TripShare.Application/Abstractions/ISmsSender.cs
@@ -0,0 +1,6 @@
+namespace TripShare.Application.Abstractions;
+
+public interface ISmsSender
+{
+    Task SendAsync(string phoneNumber, string message, CancellationToken ct);
+}
diff --git a/src/TripShare.Application/Contracts/AuthDtos.cs b/src/TripShare.Application/Contracts/AuthDtos.cs
index 133660c3b71276626c411b11649acbf1448ffcd3..e6de9448190cf7ef447ed8a0d4566ce10ad9d872 100644
--- a/src/TripShare.Application/Contracts/AuthDtos.cs
+++ b/src/TripShare.Application/Contracts/AuthDtos.cs
@@ -1,23 +1,27 @@
 namespace TripShare.Application.Contracts;
 
 public sealed record GoogleLoginRequest(string IdToken, string? DeviceToken, string? Timezone, string? Locale);
 
 public sealed record AuthResponse(
     string AccessToken,
     string RefreshToken,
     bool RequiresEmailVerification,
     bool IsSuspended,
     UserMeDto Me
 );
 
 public sealed record RefreshRequest(string RefreshToken);
 
 public sealed record UserMeDto(
     Guid Id,
     string Email,
     bool EmailVerified,
     string DisplayName,
     string? PhotoUrl,
     bool IsDriver,
     string Role
 );
+
+public sealed record SmsOtpRequest(string PhoneNumber);
+
+public sealed record SmsOtpVerifyRequest(string PhoneNumber, string Otp);
diff --git a/src/TripShare.Domain/Entities/SmsOtpToken.cs b/src/TripShare.Domain/Entities/SmsOtpToken.cs
new file mode 100644
index 0000000000000000000000000000000000000000..e51660bbdf74e2a7b55cabebe7b68a96a8172213
--- /dev/null
+++ b/src/TripShare.Domain/Entities/SmsOtpToken.cs
@@ -0,0 +1,16 @@
+namespace TripShare.Domain.Entities;
+
+public sealed class SmsOtpToken
+{
+    public Guid Id { get; set; } = Guid.NewGuid();
+    public Guid UserId { get; set; }
+    public User? User { get; set; }
+
+    public string PhoneNumber { get; set; } = "";
+    public string TokenHash { get; set; } = "";
+    public DateTimeOffset ExpiresAt { get; set; }
+    public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;
+    public DateTimeOffset? UsedAt { get; set; }
+
+    public bool IsValid => UsedAt is null && DateTimeOffset.UtcNow < ExpiresAt;
+}
diff --git a/src/TripShare.Domain/Entities/User.cs b/src/TripShare.Domain/Entities/User.cs
index 1ed942545ad38b3793f90e9c5fe4bffbd18fd6a4..af38ccd3b1545c0465be48a9339f5491b6c62020 100644
--- a/src/TripShare.Domain/Entities/User.cs
+++ b/src/TripShare.Domain/Entities/User.cs
@@ -1,27 +1,28 @@
 namespace TripShare.Domain.Entities;
 
 public sealed class User
 {
     public Guid Id { get; set; } = Guid.NewGuid();
 
     public string Email { get; set; } = "";
     public bool EmailVerified { get; set; }
 
     public string DisplayName { get; set; } = "";
     public string? PhotoUrl { get; set; }
     public string? PhoneNumber { get; set; }
+    public bool PhoneVerified { get; set; }
 
     public string AuthProvider { get; set; } = "google";
     public string ProviderUserId { get; set; } = ""; // google 'sub'
 
     public bool IsDriver { get; set; }
     public bool IsSuspended { get; set; }
     public string Role { get; set; } = "user"; // user/admin
 
     public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;
     public DateTimeOffset? LastLoginAt { get; set; }
 
     public Vehicle? Vehicle { get; set; }
 
     public List<RefreshToken> RefreshTokens { get; set; } = new();
 }
diff --git a/src/TripShare.Infrastructure/Data/AppDbContext.cs b/src/TripShare.Infrastructure/Data/AppDbContext.cs
index bd6eb265a2ed15773e4e82b041d610906bdf8013..74501db8dd10e95d656c2a90855ddc5996b11197 100644
--- a/src/TripShare.Infrastructure/Data/AppDbContext.cs
+++ b/src/TripShare.Infrastructure/Data/AppDbContext.cs
@@ -1,61 +1,63 @@
 using Microsoft.EntityFrameworkCore;
 using TripShare.Domain.Entities;
 
 namespace TripShare.Infrastructure.Data;
 
 public sealed class AppDbContext : DbContext
 {
     public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
 
     public DbSet<User> Users => Set<User>();
     public DbSet<RefreshToken> RefreshTokens => Set<RefreshToken>();
     public DbSet<EmailVerificationToken> EmailVerificationTokens => Set<EmailVerificationToken>();
+    public DbSet<SmsOtpToken> SmsOtpTokens => Set<SmsOtpToken>();
 
     public DbSet<Vehicle> Vehicles => Set<Vehicle>();
 
     public DbSet<Trip> Trips => Set<Trip>();
     public DbSet<TripRoutePoint> TripRoutePoints => Set<TripRoutePoint>();
     public DbSet<TripSegment> TripSegments => Set<TripSegment>();
 
     public DbSet<Booking> Bookings => Set<Booking>();
     public DbSet<BookingSegmentAllocation> BookingSegmentAllocations => Set<BookingSegmentAllocation>();
 
     public DbSet<Rating> Ratings => Set<Rating>();
 
     // Prod-ready features (+10): moderation & user safety
     public DbSet<Notification> Notifications => Set<Notification>();
     public DbSet<UserBlock> UserBlocks => Set<UserBlock>();
     public DbSet<Report> Reports => Set<Report>();
 
 
     protected override void OnModelCreating(ModelBuilder modelBuilder)
     {
         modelBuilder.Entity<User>(b =>
         {
             b.HasIndex(x => x.Email).IsUnique();
             b.HasIndex(x => new { x.AuthProvider, x.ProviderUserId }).IsUnique();
+            b.HasIndex(x => x.PhoneNumber);
             b.Property(x => x.Email).HasMaxLength(320);
             b.Property(x => x.DisplayName).HasMaxLength(120);
             b.Property(x => x.Role).HasMaxLength(32);
         });
 
         modelBuilder.Entity<Trip>(b =>
         {
             b.HasIndex(x => x.DriverId);
             b.Property(x => x.Currency).HasMaxLength(8);
             b.HasMany(x => x.RoutePoints).WithOne(x => x.Trip!).HasForeignKey(x => x.TripId);
             b.HasMany(x => x.Segments).WithOne(x => x.Trip!).HasForeignKey(x => x.TripId);
         });
 
         modelBuilder.Entity<TripRoutePoint>(b =>
         {
             b.HasIndex(x => new { x.TripId, x.OrderIndex }).IsUnique();
             b.Property(x => x.DisplayAddress).HasMaxLength(400);
             b.Property(x => x.PlaceId).HasMaxLength(128);
         });
 
         modelBuilder.Entity<TripSegment>(b =>
         {
             b.HasIndex(x => new { x.TripId, x.OrderIndex }).IsUnique();
             b.Property(x => x.Currency).HasMaxLength(8);
             b.Property(x => x.RowVersion).IsRowVersion();
@@ -87,27 +89,34 @@ public sealed class AppDbContext : DbContext
         modelBuilder.Entity<Notification>(b =>
         {
             b.HasIndex(x => new { x.UserId, x.IsRead, x.CreatedAt });
             b.Property(x => x.Title).HasMaxLength(140);
             b.Property(x => x.Body).HasMaxLength(600);
         });
 
         modelBuilder.Entity<UserBlock>(b =>
         {
             b.HasIndex(x => new { x.BlockerUserId, x.BlockedUserId }).IsUnique();
         });
 
         modelBuilder.Entity<Report>(b =>
         {
             b.HasIndex(x => new { x.Status, x.CreatedAt });
             b.Property(x => x.Reason).HasMaxLength(120);
             b.Property(x => x.Details).HasMaxLength(2000);
             b.Property(x => x.AdminNote).HasMaxLength(2000);
         });
 
 
         modelBuilder.Entity<Rating>(b =>
         {
             b.HasIndex(x => new { x.BookingId, x.FromUserId }).IsUnique();
         });
+
+        modelBuilder.Entity<SmsOtpToken>(b =>
+        {
+            b.HasIndex(x => x.UserId);
+            b.HasIndex(x => x.PhoneNumber);
+            b.Property(x => x.PhoneNumber).HasMaxLength(64);
+        });
     }
 }
diff --git a/src/tripshare-web/src/components/TopNav.vue b/src/tripshare-web/src/components/TopNav.vue
index 69a25ff1614c36505df0c0b3252efe0fa1c7b5d8..4b40734dff5115825bdb1772f9509e26ca7871f9 100644
--- a/src/tripshare-web/src/components/TopNav.vue
+++ b/src/tripshare-web/src/components/TopNav.vue
@@ -3,109 +3,170 @@
     <div class="mx-auto max-w-6xl px-4 py-3 flex items-center justify-between gap-3">
       <RouterLink to="/" class="flex items-center gap-3">
         <div class="h-9 w-9 rounded-2xl bg-gradient-to-br from-brand-600 to-brand-800 shadow-soft flex items-center justify-center">
           <span class="text-white font-semibold text-sm">TS</span>
         </div>
         <div class="leading-tight">
           <div class="font-semibold">TripShare</div>
           <div class="text-xs text-slate-500">Carpool, simplified</div>
         </div>
       </RouterLink>
 
       <nav class="hidden md:flex items-center gap-1">
         <RouterLink to="/" class="btn-ghost">Explore</RouterLink>
         <RouterLink v-if="auth.isAuthenticated && auth.me?.emailVerified" to="/create" class="btn-ghost">Create</RouterLink>
         <RouterLink v-if="auth.isAuthenticated" to="/my-trips" class="btn-ghost">My Trips</RouterLink>
         <RouterLink v-if="auth.isAuthenticated && auth.me?.emailVerified" to="/bookings" class="btn-ghost">Bookings</RouterLink>
         <RouterLink v-if="auth.isAuthenticated" to="/notifications" class="btn-ghost">
           <span class="inline-flex items-center gap-2">
             <BellIcon class="h-5 w-5"/>
             <span>Alerts</span>
             <span v-if="unreadCount>0" class="ml-1 inline-flex items-center justify-center h-5 min-w-5 px-1 rounded-full bg-brand-600 text-white text-xs">{{ unreadCount }}</span>
           </span>
         </RouterLink>
         <RouterLink v-if="auth.isAuthenticated" to="/profile" class="btn-ghost">Profile</RouterLink>
         <RouterLink v-if="auth.isAuthenticated" to="/safety" class="btn-ghost">Safety</RouterLink>
-        <RouterLink v-if="auth.isAuthenticated && auth.me?.role==='Admin'" to="/admin" class="btn-ghost">Admin</RouterLink>
+        <RouterLink v-if="auth.isAuthenticated && auth.me?.role==='admin'" to="/admin" class="btn-ghost">Admin</RouterLink>
       </nav>
 
       <div class="flex items-center gap-2">
         <button v-if="!auth.isAuthenticated" class="btn-primary" @click="openLogin=true">
           <ArrowRightOnRectangleIcon class="h-5 w-5 mr-2"/> Sign in
         </button>
         <RouterLink v-else to="/profile" class="btn-outline flex items-center gap-2">
           <img v-if="auth.me?.photoUrl" :src="auth.me?.photoUrl" class="h-7 w-7 rounded-full object-cover" />
           <UserCircleIcon v-else class="h-6 w-6 text-slate-500" />
           <span class="hidden sm:inline">{{ auth.me?.displayName }}</span>
         </RouterLink>
       </div>
     </div>
 
     <!-- Mobile nav -->
     <div class="md:hidden border-t border-slate-100 bg-white">
       <div class="mx-auto max-w-6xl px-4 py-2 flex items-center justify-between text-sm">
         <RouterLink to="/" class="btn-ghost px-3 py-2">Explore</RouterLink>
         <RouterLink v-if="auth.isAuthenticated && auth.me?.emailVerified" to="/create" class="btn-ghost px-3 py-2">Create</RouterLink>
         <RouterLink v-if="auth.isAuthenticated" to="/notifications" class="btn-ghost px-3 py-2">Alerts</RouterLink>
         <RouterLink v-if="auth.isAuthenticated" to="/profile" class="btn-ghost px-3 py-2">Profile</RouterLink>
       </div>
     </div>
 
     <!-- Login modal -->
     <div v-if="openLogin" class="fixed inset-0 z-40 bg-slate-900/40 flex items-center justify-center p-4">
       <div class="card w-full max-w-md p-5">
         <div class="flex items-start justify-between">
           <div>
             <div class="text-lg font-semibold">Sign in</div>
             <p class="text-sm text-slate-600 mt-1">
               Trips can be created and booked only after email verification.
             </p>
           </div>
           <button class="btn-ghost" @click="openLogin=false"><XMarkIcon class="h-5 w-5"/></button>
         </div>
-        <div class="mt-5">
-          <GoogleSignIn @success="onGoogleSuccess" />
+        <div class="mt-5 space-y-4">
+          <div>
+            <p class="text-xs uppercase tracking-wide text-slate-500 mb-2">Google</p>
+            <GoogleSignIn @success="onGoogleSuccess" />
+          </div>
+          <div class="border-t border-slate-100 pt-4">
+            <p class="text-xs uppercase tracking-wide text-slate-500 mb-2">SMS OTP</p>
+            <div class="space-y-3">
+              <div class="space-y-1">
+                <label class="block text-xs text-slate-600">Phone number</label>
+                <input v-model="smsPhone" class="input" placeholder="+94..." />
+              </div>
+              <div class="flex items-center gap-3">
+                <button class="btn-secondary" :disabled="sendingOtp || !smsPhone" @click="sendSmsOtp">
+                  <span v-if="sendingOtp">Sending...</span>
+                  <span v-else>Send code</span>
+                </button>
+                <span v-if="otpSent" class="text-xs text-green-700">Code sent</span>
+              </div>
+              <div class="space-y-1">
+                <label class="block text-xs text-slate-600">Enter code</label>
+                <input v-model="smsOtp" class="input" placeholder="6-digit code" />
+              </div>
+              <button class="btn-primary w-full" :disabled="verifying || !smsOtp" @click="verifySms">
+                <span v-if="verifying">Verifying...</span>
+                <span v-else>Sign in with SMS</span>
+              </button>
+              <p v-if="smsError" class="text-xs text-red-600">{{ smsError }}</p>
+            </div>
+          </div>
+          <p class="text-xs text-slate-500">
+            By continuing you agree to the Terms and Privacy Policy (placeholders).
+          </p>
         </div>
-        <p class="text-xs text-slate-500 mt-4">
-          By continuing you agree to the Terms and Privacy Policy (placeholders).
-        </p>
       </div>
     </div>
   </header>
 </template>
 
 <script setup lang="ts">
 import { onMounted, ref, watch } from 'vue'
 import { useAuthStore } from '../stores/auth'
 import GoogleSignIn from './GoogleSignIn.vue'
 import { http } from '../lib/api'
 import {
   ArrowRightOnRectangleIcon,
   BellIcon,
   UserCircleIcon,
   XMarkIcon
 } from '@heroicons/vue/24/outline'
 
 const auth = useAuthStore()
 const openLogin = ref(false)
 const unreadCount = ref(0)
+const smsPhone = ref('')
+const smsOtp = ref('')
+const otpSent = ref(false)
+const smsError = ref('')
+const sendingOtp = ref(false)
+const verifying = ref(false)
 
 async function refreshUnread() {
   if (!auth.isAuthenticated) { unreadCount.value = 0; return }
   // If backend doesn't have a count endpoint, approximate by fetching unreadOnly=1
   try {
     const resp = await http.get<any[]>('/notifications', { params: { unreadOnly: true, take: 50 } })
     unreadCount.value = (resp.data ?? []).length
   } catch {
     unreadCount.value = 0
   }
 }
 
 async function onGoogleSuccess(idToken: string) {
   await auth.googleLogin(idToken)
   openLogin.value = false
   await refreshUnread()
 }
 
+async function sendSmsOtp() {
+  smsError.value = ''
+  sendingOtp.value = true
+  try {
+    await auth.requestSmsOtp(smsPhone.value)
+    otpSent.value = true
+  } catch (err: any) {
+    smsError.value = err?.response?.data?.message ?? 'Failed to send code. Try again.'
+  } finally {
+    sendingOtp.value = false
+  }
+}
+
+async function verifySms() {
+  smsError.value = ''
+  verifying.value = true
+  try {
+    await auth.verifySmsOtp(smsPhone.value, smsOtp.value)
+    openLogin.value = false
+    await refreshUnread()
+  } catch (err: any) {
+    smsError.value = err?.response?.data?.message ?? 'Invalid code.'
+  } finally {
+    verifying.value = false
+  }
+}
+
 onMounted(() => { refreshUnread() })
 watch(() => auth.isAuthenticated, () => { refreshUnread() })
 </script>
diff --git a/src/tripshare-web/src/router/index.ts b/src/tripshare-web/src/router/index.ts
index 98118223fead3067db221024c66e38134a115bed..8a9aaf3c883c762bc05034f1a07771d2c96a7788 100644
--- a/src/tripshare-web/src/router/index.ts
+++ b/src/tripshare-web/src/router/index.ts
@@ -21,31 +21,31 @@ const router = createRouter({
     { path: '/create', component: CreateTrip, meta: { requiresAuth: true, requiresVerified: true } },
     { path: '/my-trips', component: MyTrips, meta: { requiresAuth: true, requiresVerified: true } },
     { path: '/bookings', component: MyBookings, meta: { requiresAuth: true, requiresVerified: true } },
     { path: '/notifications', component: Notifications, meta: { requiresAuth: true } },
     { path: '/profile', component: Profile, meta: { requiresAuth: true } },
     { path: '/vehicle', component: Vehicle, meta: { requiresAuth: true, requiresVerified: true } },
     { path: '/safety', component: Safety, meta: { requiresAuth: true } },
     { path: '/verify-email', component: VerifyEmail, meta: { requiresAuth: true } },
     { path: '/admin', component: AdminDashboard, meta: { requiresAuth: true, requiresAdmin: true } },
     { path: '/admin/reports', component: AdminReports, meta: { requiresAuth: true, requiresAdmin: true } }
   ]
 })
 
 router.beforeEach(async (to) => {
   const auth = useAuthStore()
   if (!auth.initialized) await auth.init()
 
   if ((to.meta as any)?.requiresAuth && !auth.isAuthenticated) {
     return { path: '/', query: { login: '1' } }
   }
 
   if ((to.meta as any)?.requiresVerified && auth.isAuthenticated && !auth.me?.emailVerified) {
     return { path: '/profile', query: { verify: '1' } }
   }
 
-  if ((to.meta as any)?.requiresAdmin && auth.isAuthenticated && auth.me?.role !== 'Admin') {
+  if ((to.meta as any)?.requiresAdmin && auth.isAuthenticated && auth.me?.role !== 'admin') {
     return { path: '/' }
   }
 })
 
 export default router
diff --git a/src/tripshare-web/src/stores/auth.ts b/src/tripshare-web/src/stores/auth.ts
index 9ef97086a4c01de977639deada1860ca197f3c35..99fe3526a8af4e18e11514f2185eeedf7b9c6356 100644
--- a/src/tripshare-web/src/stores/auth.ts
+++ b/src/tripshare-web/src/stores/auth.ts
@@ -1,104 +1,124 @@
 import { defineStore } from 'pinia'
 import { http } from '../lib/api'
 
 export type Me = {
   id: string
   email: string
   emailVerified: boolean
   displayName: string
   photoUrl?: string
   isDriver: boolean
-  role: 'User' | 'Admin'
+  role: Role
   ratingAverage?: number
   verified?: boolean
 }
 
+type Role = 'user' | 'admin'
+
 type AuthResponse = {
   accessToken: string
   refreshToken: string
   me: Me
 }
 
 const LS_KEY = 'tripshare.auth.v1'
 
 export const useAuthStore = defineStore('auth', {
   state: () => ({
     accessToken: '' as string,
     refreshToken: '' as string,
     me: null as Me | null,
     initialized: false
   }),
   getters: {
     isAuthenticated: (s) => !!s.accessToken && !!s.me
   },
   actions: {
+    normalizeMe(raw: any): Me {
+      const rawRole = (raw?.role ?? '').toString().toLowerCase()
+      const role: Role = rawRole === 'admin' ? 'admin' : 'user'
+      return { ...raw, role }
+    },
+
     async init() {
       try {
         const raw = localStorage.getItem(LS_KEY)
         if (raw) {
           const parsed = JSON.parse(raw)
           this.accessToken = parsed.accessToken ?? ''
           this.refreshToken = parsed.refreshToken ?? ''
-          this.me = parsed.me ?? null
+          this.me = parsed.me ? this.normalizeMe(parsed.me) : null
         }
       } catch {
         // ignore
       }
       this.initialized = true
 
       // if tokens exist, refresh me silently
       if (this.accessToken && this.me) {
         try {
           await this.loadMe()
         } catch {
           // token may be stale; try refresh once
           if (this.refreshToken) {
             try {
               await this.refresh()
               await this.loadMe()
             } catch {
               this.logout()
             }
           }
         }
       }
     },
 
     persist() {
       localStorage.setItem(
         LS_KEY,
         JSON.stringify({ accessToken: this.accessToken, refreshToken: this.refreshToken, me: this.me })
       )
     },
 
     logout() {
       this.accessToken = ''
       this.refreshToken = ''
       this.me = null
       localStorage.removeItem(LS_KEY)
     },
 
     async googleLogin(idToken: string) {
       const resp = await http.post<AuthResponse>('/auth/google', { idToken })
       this.accessToken = resp.data.accessToken
       this.refreshToken = resp.data.refreshToken
-      this.me = resp.data.me
+      this.me = this.normalizeMe(resp.data.me)
+      this.persist()
+    },
+
+    async requestSmsOtp(phoneNumber: string) {
+      await http.post('/auth/sms/request', { phoneNumber })
+    },
+
+    async verifySmsOtp(phoneNumber: string, otp: string) {
+      const resp = await http.post<AuthResponse>('/auth/sms/verify', { phoneNumber, otp })
+      this.accessToken = resp.data.accessToken
+      this.refreshToken = resp.data.refreshToken
+      this.me = this.normalizeMe(resp.data.me)
       this.persist()
     },
 
     async refresh() {
       if (!this.refreshToken) throw new Error('No refresh token')
       const resp = await http.post<AuthResponse>('/auth/refresh', { refreshToken: this.refreshToken })
       this.accessToken = resp.data.accessToken
       this.refreshToken = resp.data.refreshToken
-      this.me = resp.data.me
+      this.me = this.normalizeMe(resp.data.me)
       this.persist()
     },
 
     async loadMe() {
       const resp = await http.get<Me>('/users/me')
-      this.me = resp.data
+      this.me = this.normalizeMe(resp.data)
       this.persist()
     }
   }
 })
